class MedianFinder {
    // Max Heap for the smaller half
    PriorityQueue<Integer> left_max_heap = new PriorityQueue<>(Collections.reverseOrder());
    // Min Heap for the larger half
    PriorityQueue<Integer> right_min_heap = new PriorityQueue<>();

    public MedianFinder() {}

    public void addNum(int num) {
        // Step 1: Add to one of the heaps
        if (left_max_heap.isEmpty() || num <= left_max_heap.peek()) {
            left_max_heap.offer(num);
        } else {
            right_min_heap.offer(num);
        }

        // Step 2: Balance the two heaps
        if (left_max_heap.size() > right_min_heap.size() + 1) {
            right_min_heap.offer(left_max_heap.poll());
        } else if (right_min_heap.size() > left_max_heap.size()) {
            left_max_heap.offer(right_min_heap.poll());
        }
    }

    public double findMedian() {
        if (left_max_heap.size() == right_min_heap.size()) {
            // even number of elements
            return (left_max_heap.peek() + right_min_heap.peek()) / 2.0;
        } else {
            // odd number of elements
            return left_max_heap.peek();
        }
    }
}
